DYNAMICS

def __init__(self,dyn,MSX='SX',compile=False):

    """
    Dynamics constructor. It requires a dictionary as an input with keys:

        - 'x': symbolic state variable (n_x,1)
        - 'u': symbolic input variable (n_u,1)
        - 'x_dot': symbolic derivative of the state (n_x,1)
        - 'x_next': symbolic next state (n_x,1)
        - 'w': (optional) symbolic noise variable (n_w,1)
        - 'd': (optional) symbolic disturbance variable (n_d,1)
        - 'x0': (optional) initial state (n_x,1)
        - 'u0': (optional) initial input (n_u,1)
        - 'w0': (optional) nominal noise (n_w,1)
        - 'd0': (optional) nominal disturbance (n_d,1)

    additionally, you can specify the symbolic variable used ('SX' or 'MX'), as well as the 
    compilation option (Boolean).

    """

INGREDIENTS

# # type of symbolic variable used (either SX or MX)
# __MSX = None

# """
# Dimension dictionary with keys

#     - N: horizon of the MPC, positive integer
#     - u: number of inputs, positive integer
#     - x: number of states, positive integer
#     - eps: number of slack variables, positive integer [optional, defaults to 0]

# """
# __dim = {}

# """
# Model dictionary with entries

#     - A: list of length N of matrices (n_x,n_x)
#     - B: list of length N of matrices (n_x,n_u)
#     - x0: symbolic variable representing the initial state (n_x,1)
#     - c: list of length N of matrices (n_x,1) [optional, defaults to 0]
        
# where the dynamics are given by x[t+1] = A[t]x[t] + B[t]u[t] + c[t], with x[0] = x0.
# """
# __model = {}

# """
# Cost dictionary with keys
            
#     - 'Qx': state stage cost, list of length N of matrices (n_x,n_x)
#     - 'Ru': input stage cost, list of length N of matrices (n_u,n_u)
#     - 'x_ref': state reference, list of length N of vectors (n_x,1) [optional, defaults to 0]
#     - 'u_ref': reference input, list of length N of vectors (n_u,1) [optional, defaults to 0]
#     - 's_lin': linear penalty on slack variables, nonnegative scalar [optional, defaults to 0]
#     - 's_quad': quadratic penalty on slack variables, positive scalar [optional, defaults to 0]

# where the stage cost is given by
    
#     (x[t]-x_ref[t])'Qx[t](x[t]-x_ref[t]) + (u[t]-u_ref[t])'Ru[t](u[t]-u_ref[t]) + s_lin*e[t] + s_quad*e[t]**2
# """
# __cost = {}

# """
#     Constraints dictionary with keys

#     - 'Hx': list of length N of matrices (=,n_x)
#     - 'hx': list of length N of vectors (=,1)
#     - 'Hx_e': list of length N of matrices (=,n_eps) [optional, defaults to zero]
#     - 'Hu': list of length N of matrices (-,n_u)
#     - 'hu': list of length N of vectors (-,1)
    
# where the constraints at each time-step are
    
#     Hx[t]*x[t] <= hx[t] - Hx_e[t]*e[t],
#     Hu[t]*u[t] <= hu[t],
        
# where e[t] denotes the slack variables.
# """
# __cst = {}

class Ingredients:
    """
    QP ingredients, contains the following keys

        - 'Q': Hessian of QP (n_y,n_y)
        - 'Qinv': inverse of Hessian of QP (n_y,n_y)
        - 'q': gradient of cost of QP (n_y,1)
        - 'G': linear inequality constraint matrix (n_in,n_y)
        - 'g': linear inequality constraint vector (n_in,1)
        - 'H': Hessian of dual problem (n_z,n_z)
        - 'h': gradient of cost of dual problem (n_z,1)
        - 'A': stacked inequality constraint matrix for casadi's conic interface,
               specifically, A = vertcat(G,F) (n_in+n_eq,n_y)
        - 'lba': lower bound of inequality constraints, lba = (-inf,f) (n_in+n_eq,1)
        - 'uba': upper bound of inequality constraints, uba = (g,f) (n_in+n_eq,1)

    remember that the primal problem is a QP with the following structure:

        min 1/2 y'Qy + q'y
        s.t. Gy <= g
             Fy = f
    
    and the dual problem is a QP with the following structure:

        min 1/2 z'Hz + h'z
        s.t. z=(lam,mu)
             lam >= 0
    """

    def __init__(self,model,cost,constraints):

        """
        This function converts an MPC problem of the form

        minimize      1/2 (x_N-x_r_N)^T Qx[t] (x_N-x_r_N)
         x,u,e      + 1/2 \sum_{t=0}^{N-1} [ (x_t-x_r_t)^T Qx[t] (x_t-x_r_t) + (u_t-u_r_t)^T Ru[t] (u_t-u_r_t) ]
                    + 1/2 \sum_{t=0}^{N} [ c_lin e_t + c_quad e_t^T e_t ]

        subject to  x_{t+1} = A_t x_t + B_t u_t + c_t,  t = 0,...,N-1,
                    H_x x_t <= h_x - H_e e_t,           t = 0,...,N,
                    H_u u_t <= h_u,                     t = 0,...,N-1,
                    e_t >= 0,                           t = 0,...,N,
                    x_0 = x,
        
        where x_t,u_t denote state and input at time t, N is the horizon of the MPC, e_t is a slack variable (which only affects certain)
        states, as encoded in matrix H_e, and x is the current state of the system, to a QP of the form

        minimize    1/2 y'Qy + q'y
            
        subject to  Gy <= g
                    Fy = f

        where y = col(x,u,e). The outputs are the matrices G, g, F, f, Q, Qinv=inv(Q), the dictionary idx containing the indexing of the output optimization variables of the QP. This function sets up the following keys in idx:

            - 'u': range of all inputs
            - 'x': range of all states
            - 'y': range of all state-input variables
            - 'eps': range of all slack variables (if present)
            - 'u0': range of first input
            - 'u1': range of second input
            - 'x_shift': states shifted by one time-step (last state repeated)
            - 'u_shift': inputs shifted by one time-step (last input repeated)
            - 'y_shift': concatenation of x_shift and u_shift (and slacks shifted if present)

        """

QP

    __x = None
    __y = None
    __lam = None
    __mu = None
    __z = None
    __y_lin = None
    __p_t = None
    __pf_t = None
    __p_qp = None
    __init = {'y_lin':None}

    @property
    def ingredients(self):
        """
        QP elements, setup through call to scenario.__makeQP. It is a dictionary containing the following keys:

            - 'Q': Hessian of QP (n_y,n_y)
            - 'Qinv': inverse of Hessian of QP (n_y,n_y)
            - 'q': gradient of cost of QP (n_y,1)
            - 'G': linear inequality constraint matrix (n_in,n_y)
            - 'g': linear inequality constraint vector (n_in,1)
            - 'H': Hessian of dual problem (n_z,n_z)
            - 'h': gradient of cost of dual problem (n_z,1)
            - 'A': stacked inequality constraint matrix for casadi's conic interface,
                    specifically, A = vertcat(G,F) (n_in+n_eq,n_y)
            - 'lba': lower bound of inequality constraints, lba = (-inf,f) (n_in+n_eq,1)
            - 'uba': upper bound of inequality constraints, uba = (g,f) (n_in+n_eq,1)
            - 'dense_qp: this is another dictionary containing the elements of the dense
                version of the QP, it is created by the function scenario.__makeDenseMPC,
                and it contains the keys
                    - 'G_x', 'G_u', 'g_c': matrices satisfying x = G_x*x0 + G_u*u + g_c
                    - 'Qx', 'Ru', 'x_ref', 'u_ref': cost function (x-x_ref)'Qx(x-x_ref) + (u-u_ref)'Ru(u-u_ref)
                    - 'Hx', 'Hu', 'hx', 'hu': polyhedral constraints Hx*x <= hx, Hu*u <= hu

        remember that the primal problem is a QP with the following structure:

            min 1/2 y'Qy + q'y
            s.t. Gy <= g
                    Fy = y

        and the dual problem is a QP with the following structure:

            min 1/2 z'Hz + h'z
            s.t. z=(lam,mu)
                    lam >= 0
        """

    @property
    def idx(self):
        """
        idx is a dictionary containing the indexing of the input and output optimization variables of the QP.
        It contains keys setup by different functions. Specifically, calling scenario.__makeSparseMPC creates
        a key 'out' which contains the index of the output QP variables. idx['out'] is itself a dictionary
        with keys

            - 'u': range of all inputs
            - 'x': range of all states
            - 'y': range of all state-input variables
            - 'eps': range of all slack variables (if present)
            - 'u0': range of first input
            - 'u1': range of second input
            - 'x_shift': states shifted by one time-step (last state repeated)
            - 'u_shift': inputs shifted by one time-step (last input repeated)
            - 'y_shift': concatenation of x_shift and u_shift (and slacks shifted if present)

        the second entry is 'in', which contains the index of the input QP variables (i.e. p_QP, not including
        pf_t). idx['in'] is itself a dictionary set up by __makeQP with keys

            - 'x0': initial state
            - 'y_lin': linearization trajectory
            - 'p_t': parameters that are optimized in the upper-level

        Note that not all parameters need to be present.
        """

    @property
    def solve(self):
        """
        this function takes in p_QP and returns the optimal solution of the QP problem. Based on the type
        of warmstarting (i.e. x_lam_mu or x), the function will take the following inputs:

            - x_lam_mu: p_QP (including pf_t), x0=None, lam=None, mu=None
            - x: p_QP (including pf_t), x0=None

        the output is lam, mu, y.
        """

    @property
    def denseSolve(self):
        """
        this function takes in p_QP and returns the optimal solution of the QP problem in dense form.
        Based on the type of warmstarting (i.e. x_lam_mu or x), the function will take the following inputs:

            - x_lam_mu: p_QP (including pf_t), x0=None, lam=None, mu=None
            - x: p_QP (including pf_t), x0=None

        the output is lam, mu, y.
        """

    @property
    def qp_sparse(self):
        """
        This function takes in p_QP and returns the sparse ingredients, which are:
                
            - F,f,G,g,Q,q in the separate mode, where the QP is formulated as

                min 1/2 y'Qy + q'y
                s.t. Gy <= g
                        Fy = y

            - A,lba,uba,Q,q in the stacked mode, where the QP is formulated as

                min 1/2 y'Qy + q'y
                s.t. lba <= Ay <= uba
        """

    @property
    def qp_dense(self):
        """
        this function takes in p_QP (including pf_t) and returns the dense ingredients, which are:

            - 'G_x', 'G_u', 'g_c': matrices satisfying x = G_x*x0 + G_u*u + g_c
            - 'Qx', 'Ru', 'x_ref', 'u_ref': cost function (x-x_ref)'Qx(x-x_ref) + (u-u_ref)'Ru(u-u_ref)
            - 'Hx', 'Hu', 'hx', 'hu': polyhedral constraints Hx*x <= hx, Hu*u <= hu
                
        where the QP is formulated as

            min 1/2 u'(G_x'QxG_x + Ru)u + (G_x'Qx(G_x*x0 + g_c - x_ref) - Ru*u_ref)'u
            s.t. Hx*(G_x*x0 + G_u*u + g_c) <= hx
                    Hu*u <= hu
        """

    @property
    def dual_sparse(self):
        """
        This function takes in p_QP (including pf_t) and returns the dual ingredients H,h, where the dual
        QP is formulated as:

            min 1/2 z'Hz + h'z
            s.t. z >= 0
        """

    @property
    def J(self):
        """
        this function takes in the dual variables lam, mu, and the parameters p_QP necessary to setup the
        QP (including pf_t), and returns the following quantities in a list:

            - J_F_z: conservative jacobian of dual fixed point condition wrt z
            - J_F_p: conservative jacobian of dual fixed point condition wrt p_t
            - J_y_p: conservative jacobian of primal variable wrt p_t
            - J_y_z_mat: conservative jacobian of primal variable wrt z
        """

    @property
    def J_y_p(self):
        """
        this function takes in lam, mu, p_QP (including pf_t), and optionally t (which defaults to 1), and
        returns the inner product between the conservative jacobian J_y_p of y wrt p_t and t.
        """
        return self.__J_y_p

    @property
    def options(self):
        """
        Options dictionary. Possible keys are:

            - 'linearization': 'trajectory', 'state' or 'none' (default is 'trajectory')
            - 'slack': True or False (default is False)
            - 'qp_mode': 'stacked' or 'separate' (default is 'stacked')
            - 'solver': 'qpoases','osqp','cplex','gurobi','daqp','qrqp' (default is 'qpoases')
            - 'warmstart': 'x_lam_mu' (warmstart both primal and dual variables) or 'x' (warmstart only 
                        primal variables) (default is 'x_lam_mu')
            - 'jac_tol': tolerance below which multipliers are considered zero (default is 8)
            - 'jac_gamma': stepsize in optimality condition used to apply the IFT (default is 0.001)
            - 'compile_qp_sparse': True or False (default is False)
            - 'compile_jac': True or False (default is False)
        """

    @property
    def init(self):
        """
        init contains the initial value of the QP variables, it can be set through __setInit.
        """

    def __checkInit(self, value):

        # preallocate output dictionary
        out = {}

        # check if input dictionary contains 'y_lin' key
        if 'y_lin' in value:

            if 'y_lin' not in self.param:
                raise Exception('Current MPC does not require a linearization trajectory.')

            # if so, extract y_lin
            y_lin = value['y_lin']

            # check if y_lin has correct dimension (unless the 'adpative' or the 'optimal' option is passed)
            if (y_lin != 'adaptive' or y_lin != 'optimal') and (y_lin.shape[0] != self.param['y_lin'].shape[0]):
                raise Exception('y_lin has incorrect dimension.')

            # add new initial linearization
            out = {'y_lin':y_lin}

        return out

    def __makeSparseQP(self,p=None,pf=None,mode='stacked',solver='qpoases',warmstart='x_lam_mu',compile=False):
        
        """
        This function creates the functions necessary to solve the MPC problem in QP form. Specifically, this function
        sets the following properties of QP:

            - qp_sparse: this function takes in p_QP and returns the sparse ingredients, which are:
                
                - F,f,G,g,Q,q in the separate mode, where the QP is formulated as

                    min 1/2 y'Qy + q'y
                    s.t. Gy <= g
                         Fy = f

                - A,lba,uba,Q,q in the stacked mode, where the QP is formulated as

                    min 1/2 y'Qy + q'y
                    s.t. lba <= Ay <= uba

            - dual_sparse: this function takes in p_QP and returns the dual ingredients H,h, where the dual
              QP is formulated as:

                min 1/2 z'Hz + h'z
                s.t. z >= 0
            
            - qp_dense: this function takes in p_QP and returns the dense ingredients, which are:

                - 'G_x', 'G_u', 'g_c': matrices satisfying x = G_x*x0 + G_u*u + g_c
                - 'Qx', 'Ru', 'x_ref', 'u_ref': cost function (x-x_ref)'Qx(x-x_ref) + (u-u_ref)'Ru(u-u_ref)
                - 'Hx', 'Hu', 'hx', 'hu': polyhedral constraints Hx*x <= hx, Hu*u <= hu
              
              where the QP is formulated as

                min 1/2 u'(G_x'QxG_x + Ru)u + (G_x'Qx(G_x*x0 + g_c - x_ref) - Ru*u_ref)'u
                s.t. Hx*(G_x*x0 + G_u*u + g_c) <= hx
                     Hu*u <= hu

            - solve: this function takes in p_QP and returns the optimal solution of the QP problem.
              Based on the type of warmstarting (i.e. x_lam_mu or x), the function will take the following 
              inputs:

                - x_lam_mu: p_QP, x0=None, lam=None, mu=None
                - x: p_QP, x0=None

              the output is lam, mu, y.
                
        This function also sets up all the symbolic variables and their dimensions.

        Note that p_QP contains all necessary parameters required to setup the ingredients at any given time-step,
        e.g. x0,y_lin,p_t,pf_t). This is different from the p_QP stored as a parameter, which does not contain pf.

        Additionally, this functions sets up the 'in' entry of the idx dictionary of scenario.QP, which contains the
        indexing of all the input parameters in p_QP:

            - 'x0': initial state
            - 'y_lin': linearization trajectory
            - 'p_t': parameters that are optimized in the upper-level
        
        Note that not all parameters need to be present.

        """
    def _makeConsJac(self):
        """
        This function sets up the functions that compute the conservative jacobian of the QP solution.
        Specifically, two functions are set in the QP class:

            - J: this function takes in the dual variables lam, mu, and the parameters p_QP necessary 
                 to setup the QP (including pf_t), and returns the following quantities in a list:

                 - J_F_z: conservative jacobian of dual fixed point condition wrt z
                 - J_F_p: conservative jacobian of dual fixed point condition wrt p_t
                 - J_y_p: conservative jacobian of primal variable wrt p_t
                 - J_y_z_mat: conservative jacobian of primal variable wrt z

            - J_y_p: this function takes in lam, mu, p_QP (including pf_t), and optionally t (which
              defaults to 1), and returns the inner product between the conservative jacobian J_y_p
              of y wrt p_t and t.
        """

SCENARIO

    def makeMPC(self,N,cost,cst,p=None,pf=None,model=None,options={}):

        """
        This function allows the user to setup the MPC formulation.
        Inputs:

            - N: horizon of the MPC (natural number)
            
            - cost: dictionary containing the cost function. The dictionary must contain the keys
                
                - 'Qx': state cost matrix (n_x*(N-1),n_x*(N-1))
                - 'Qn': terminal state cost matrix (n_x,n_x)
                - 'Ru': input cost matrix (n_u*N,n_u*N)
                - 'x_ref': (optional, defaults to 0) reference state (n_x,1)
                - 'u_ref': (optional, defaults to 0) reference input (n_u,1)
                - 's_lin': (optional, defaults to 0) linear penalty on slack variables
                - 's_quad': (optional, defaults to 1) quadratic penalty on slack variables

              recall that the cost is (x-x_ref)'blkdiag(Qx,Qn)(x-x_ref) + (u-u_ref)'Ru(u-u_ref) + s_lin*e + s_quad*e^2
              Note that x and u are here of dimensions (n_x*N,1) and (n_u*N,1) respectively (i.e. they contain all time-steps).
            
            - cst: dictionary containing the constraints. The dictionary must contain the keys
            
                - 'Hx': state constraint matrix (=,n_x*N)
                - 'hx': state constraint vector (=,1)
                - 'Hx_e': (optional, defaults to identity) matrix that softens constraints (=,n_eps)
                - 'Hu': input constraint matrix (-,n_u*N)
                - 'hu': input constraint vector (-,1)
              
              recall that the constraints are Hx*x + Hx_e*e <= hx, Hu*u <= hu, where e are the slack variables.
              Note that x and u are here of dimensions (n_x*N,1) and (n_u*N,1) respectively (i.e. they contain all time-steps).

            - p: symbolic parameter used to set up the MPC at any given time-step. This is (part of) the decision variable
                 of the upper-level optimization problem.

            - pf: symbolic parameter used to set up the MPC at the first time-step. This is not a decision variable of the
                  upper-level function (e.g. the reference to be tracked).

            - model (optional): dictionary containing the linear model of the system. The dictionary must contain the keys
              A,B,c where the prediction model is x[t+1] = Ax[t] + Bu[t] + c. Note that c is optional and defaults to 0.

            - options (optional): dictionary containing the options. The dictionary can contain the following keys:

                - 'linearization': 'trajectory', 'state' or 'none' (default is 'trajectory')
                - 'slack': True or False (default is False)
                - 'qp_mode': 'stacked' or 'separate' (default is 'stacked')
                - 'solver': 'qpoases','osqp','cplex','gurobi','daqp','qrqp' (default is 'qpoases')
                - 'warmstart': 'x_lam_mu' (warmstart both primal and dual variables) or 'x' (warmstart only 
                            primal variables) (default is 'x_lam_mu')
                - 'jac_tol': tolerance below which multipliers are considered zero (default is 8)
                - 'jac_gamma': stepsize in optimality condition used to apply the IFT (default is 0.001)
                - 'compile_qp_sparse': True or False (default is False)
                - 'compile_jac': True or False (default is False)
                
        """

        # check if linearization option was passed
        if 'linearization' not in options:
            options['linearization'] = 'trajectory'

        # check if a model was passed
        if model is None:
            A_list, B_list, c_list, y_lin = self.linearize(N,linearization=options['linearization'])
            model = {'A':A_list,'B':B_list,'c':c_list,'y_lin':y_lin,'x0':self.param['x']}
            # check if model is affine
            if y_lin is None:
                options['linearization'] = 'none'

        # extract y_lin from model if present
        if 'y_lin' in model:
            y_lin = model['y_lin']
        else:
            y_lin = None

        # create MPC class
        if self.__MSX == SX:
            MSX = 'SX'
        if self.__MSX == MX:
            MSX = 'MX'
        mpc = MPC(N,model,cost,cst,MSX)
        
        # create QP ingredients
        G,g,F,f,Q,Qinv,q,idx,denseQP = mpc.MPC2QP()

        # create QP
        self.makeQP(G,g,F,f,Q,Qinv,q,idx,y_lin,denseQP,p,pf,options)

SCENARIO

    def make_trajectory_opt(self):

        """
        This function creates a (possibly nonlinear) trajectory optimization solver for the full
        upper-level problem. The solver uses the tracking cost and the constraint violation of the
        upper-level combined with the nominal (possibly nonlinear) dynamics.

        This function returns a solver that takes the following inputs

            - x0: initial condition (n_x,1)
            - x_init: state trajectory warm start (n_x,T+1)
            - u_init: input trajectory warm start (n_u,T)

        and returns the following outputs

            - S: simVar object containing the solution (note that only S.x, S.u, and S.cost are nonzero)
            - solved: boolean indicating whether the problem was solved successfully
        """

    def __getInitParameters(self,init={}):

        """
        This function takes in a dictionary containing user-defined initial conditions
        and returns the following quantities in a list: p,pf,w,d,y,x, where each quantity
        is either a single DM vector or a list of DM vectors, depending on whether the
        user passed a single vector or a list of vectors in init.

        Note that w should be passed either as single vector of dimension (n_w,1), which
        will be repeated for all time steps, as a matrix of dimension (n_w,T), where
        each column represents the noise at a given time step, or as a list of matrices
        of dimension (n_w,T), where each element of the list is the noise at each time
        step for a given scenario.

        Accepted keys in the dictionary are: p,pf,w,d,y_lin,x.
        """

    def simulate(self,init=None,options=None):

        """
        This function runs a single simulation of the closed-loop system and returns a list
        S, out_dict, qp_failed

            - S: simVar object containing the simulation results
            - out_dict: dictionary containing debug information about the QP calls, possible keys
                        could be 'qp_time', 'jac_time', 'qp_debug', 'qp_ingredients'
            - qp_failed: boolean indicating whether the QP failed (and simulation was interrupted)

        The function takes the following inputs:

            - init: dictionary containing the initial conditions for the simulation. The dictionary
                    can contain the following keys:

                    - x: initial state of the system (required)
                    - p: parameters of the system (required if p is a parameter)
                    - pf: fixed parameters of the system (required if pf is a parameter)
                    - w: noise of the system (required if w is a parameter)
                    - d: model uncertainty of the system (required if d is a parameter)
                    - y_lin: linearization trajectory of the system

                    Note that w should be passed either as single vector of dimension (n_w,1), which
                    will be repeated for all time steps, as a matrix of dimension (n_w,T), where
                    each column represents the noise at a given time step, or as a list of matrices
                    of dimension (n_w,T), where each element of the list is the noise at each time
                    step for a given scenario.

            - options: dictionary containing the following keys:

                    - mode: 'optimize' (jacobians are computed) or 'simulate' (jacobians are not computed)
                            or 'dense' (dense mode is used and jacobians are not computed)
                    - shift_linearization: True (default) if the input-state trajectory used for
                                           linearization should be shifted, False otherwise
                    - 'warmstart_first_qp':True (default) if the first QP should be solved twice (with
                                           propagation of the sensitivity)
                    - 'debug_qp': False (default), or True if debug information about the QP should be stored
                    - epsilon: perturbation magnitude used to compute finite difference derivatives of QP,
                               default is 1e-6
                    - roundoff_qp: number of digits below which QP derivative error is considered zero,
                                   default is 10
                    - 'compute_qp_ingredients':False (default), or True if QP ingredients should be saved
                    - 'warmstart_shift': True (default) if the primal (or primal-dual) warmstart should be shifted
        """